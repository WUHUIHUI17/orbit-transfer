<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å«æ˜Ÿå˜è½¨æ¨¡æ‹Ÿå™¨</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #02040a;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: #eee;
            user-select: none;
        }
        
        canvas { 
            display: block; 
            width: 100%; 
            height: 100vh;
            cursor: grab;
        }
        canvas:active { cursor: grabbing; }

        .panel {
            position: absolute;
            background: rgba(20, 24, 30, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            z-index: 10;
        }

        #right-panel {
            top: 30px;
            right: 30px;
            width: 260px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .section-title {
            font-size: 12px;
            color: #888;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 10px 12px;
            border-left: 3px solid #666;
            margin-bottom: 8px;
        }
        .card-title { font-weight: bold; font-size: 14px; color: #fff; margin-bottom: 4px; }
        .card-data { font-size: 12px; color: #aaa; font-family: monospace; }

        .control-group { display: flex; gap: 10px; }
        .engine-btn {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            font-size: 15px;
            color: white;
            cursor: pointer;
            transition: all 0.1s;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .engine-btn:active { transform: scale(0.96); }
        .engine-btn span { font-size: 18px; margin-bottom: 4px; }
        
        #btn-accel {
            background: linear-gradient(135deg, #ff9900, #ff5500);
            box-shadow: 0 4px 15px rgba(255, 85, 0, 0.3);
        }
        #btn-decel {
            background: linear-gradient(135deg, #00aaff, #0066ff);
            box-shadow: 0 4px 15px rgba(0, 102, 255, 0.3);
        }

        .time-bar {
            display: flex;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            padding: 2px;
            gap: 4px;
        }
        .time-opt {
            flex: 1;
            text-align: center;
            padding: 6px;
            font-size: 12px;
            cursor: pointer;
            border-radius: 4px;
            color: #aaa;
        }
        .time-opt.active { background: #eee; color: #000; font-weight: bold; }

        #telemetry-panel { bottom: 30px; left: 30px; width: 320px; }

        .data-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }
        .data-label { color: #aaa; }
        .data-val { font-family: 'Consolas', monospace; font-weight: bold; color: #fff; }
        .highlight { color: #00ff88; }

        .bar-container { margin-top: 15px; }
        .bar-header { display: flex; justify-content: space-between; font-size: 11px; color: #888; margin-bottom: 4px; }
        .progress-track {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        .progress-fill { height: 100%; border-radius: 3px; width: 0%; transition: width 0.1s; }
        #fill-ke { background: linear-gradient(90deg, #00ff88, #00cc66); }
        #fill-pe { background: linear-gradient(90deg, #ffaa00, #ff8800); }
    </style>
</head>
<body>

    <div id="right-panel" class="panel">
        <div class="section-title">ç›®æ ‡è½¨é“ (Target)</div>
        <div class="info-card" style="border-left-color: #4cc9f0;">
            <div class="card-title">è¿‘åœ°è½¨é“ LEO</div>
            <div class="card-data">v â‰ˆ 7.67 km/s | h = 400 km</div>
        </div>
        <div class="info-card" style="border-left-color: #ffcc00;">
            <div class="card-title">åŒæ­¥è½¨é“ GEO</div>
            <div class="card-data">v â‰ˆ 3.07 km/s | h = 35,786 km</div>
        </div>

        <div class="section-title" style="margin-top:10px;">ä¸»å¼•æ“ (Impulse)</div>
        <div class="control-group">
            <button id="btn-accel" class="engine-btn"><span>ğŸ”¥</span> åŠ é€Ÿ</button>
            <button id="btn-decel" class="engine-btn"><span>ğŸ›‘</span> å‡é€Ÿ</button>
        </div>

        <div class="section-title" style="margin-top:10px;">æ—¶é—´åŠ é€Ÿ (Time Warp)</div>
        <div class="time-bar">
            <div class="time-opt active" onclick="setTime(500)">500x</div>
            <div class="time-opt" onclick="setTime(1000)">1000x</div>
            <div class="time-opt" onclick="setTime(3000)">3000x</div>
        </div>
        
        <div style="text-align:center; margin-top:10px; cursor:pointer; font-size:12px; color:#666;" onclick="resetSim()">
            ğŸ”„ é‡ç½®æ¨¡æ‹Ÿ
        </div>
    </div>

    <div id="telemetry-panel" class="panel">
        <div class="section-title">é¥æµ‹æ•°æ® (Telemetry)</div>
        <div class="data-row">
            <span class="data-label">è½¨é“é«˜åº¦ Altitude</span>
            <span class="data-val" style="color:#4cc9f0"><span id="val-alt">0</span> km</span>
        </div>
        <div class="data-row">
            <span class="data-label">åˆ‡å‘é€Ÿåº¦ Velocity</span>
            <span class="data-val"><span id="val-vel">0</span> km/s</span>
        </div>
        <hr style="border:0; border-top:1px solid rgba(255,255,255,0.1); margin:10px 0;">
        <div class="data-row">
            <span class="data-label">è¿œåœ°ç‚¹ Apogee</span>
            <span class="data-val highlight"><span id="val-apo">0</span> km</span>
        </div>
        <div class="data-row">
            <span class="data-label">è¿‘åœ°ç‚¹ Perigee</span>
            <span class="data-val highlight"><span id="val-peri">0</span> km</span>
        </div>
        <div class="bar-container">
            <div class="bar-header"><span>åŠ¨èƒ½ Kinetic</span><span>Speed</span></div>
            <div class="progress-track"><div id="fill-ke" class="progress-fill"></div></div>
        </div>
        <div class="bar-container">
            <div class="bar-header"><span>åŠ¿èƒ½ Potential</span><span>Height</span></div>
            <div class="progress-track"><div id="fill-pe" class="progress-fill"></div></div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

<script>
    const DPR = window.devicePixelRatio || 1;

    const PHYSICS = {
        R: 6371,                 // åœ°çƒåŠå¾„ km
        GM: 398600.4418,         // Î¼ = GM, km^3/s^2
        scale: 0.04
    };

    const LEO_ALT = 400;
    const LEO_R = PHYSICS.R + LEO_ALT;
    const GEO_ALT = 35786;
    const GEO_R = PHYSICS.R + GEO_ALT;

    // å‚è€ƒè½¨é“ç‚¹é›†ï¼šLEO åœ†ã€GEO åœ†ã€éœæ›¼è½¬ç§»è½¨é“
    const refOrbits = {
        leo: [],
        geo: [],
        transfer: []
    };

    let state = {
        pos: {x: 0, y: 0},
        vel: {x: 0, y: 0},
        path: [],
        timeScale: 500,
        particles: []
    };

    let view = { zoom: 1.0, x: 0, y: 0, dragging: false, lastX: 0, lastY: 0 };

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    const ui = {
        alt: document.getElementById('val-alt'),
        vel: document.getElementById('val-vel'),
        apo: document.getElementById('val-apo'),
        peri: document.getElementById('val-peri'),
        btnAccel: document.getElementById('btn-accel'),
        btnDecel: document.getElementById('btn-decel'),
        barKe: document.getElementById('fill-ke'),
        barPe: document.getElementById('fill-pe'),
        timeOpts: document.querySelectorAll('.time-opt')
    };

    const earthImg = new Image();
    earthImg.src = "earth.jpg"; 
    earthImg.onload = () => { if(!running) loop(); };
    earthImg.onerror = () => { console.warn("æœªæ‰¾åˆ°å›¾ç‰‡"); if(!running) loop(); };

    let running = false;

    function resize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        canvas.width = width * DPR;
        canvas.height = height * DPR;
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(DPR, DPR);
        ctx.textBaseline = 'middle';
    }
    window.addEventListener('resize', resize);

    function buildRefOrbits() {
        const steps = 360;

        function makeCircle(radius) {
            const pts = [];
            for (let i = 0; i <= steps; i++) {
                const ang = i / steps * 2 * Math.PI;
                pts.push({
                    x: radius * Math.cos(ang),
                    y: radius * Math.sin(ang)
                });
            }
            return pts;
        }

        refOrbits.leo = makeCircle(LEO_R);
        refOrbits.geo = makeCircle(GEO_R);

        // éœæ›¼è½¬ç§»è½¨é“ï¼šè¿‘åœ°ç‚¹ LEO_Rï¼Œè¿œåœ°ç‚¹ GEO_Rï¼Œæ•´ä½“æ—‹è½¬ Ï€ï¼Œä½¿è¿‘åœ°ç‚¹åœ¨ -x æ–¹å‘
        const rp = LEO_R;
        const ra = GEO_R;
        const a = (rp + ra) / 2;
        const e = (ra - rp) / (ra + rp);
        const pts = [];
        for (let i = 0; i <= steps; i++) {
            const f = i / steps * 2 * Math.PI;
            const f2 = f + Math.PI; // æ—‹è½¬ Ï€ï¼Œä½¿è¿‘åœ°ç‚¹åœ¨ (-rp,0)
            const r = a * (1 - e*e) / (1 + e * Math.cos(f2));
            pts.push({
                x: r * Math.cos(f2),
                y: r * Math.sin(f2)
            });
        }
        refOrbits.transfer = pts;
    }

    function resetSim() {
        const r = LEO_R;      // 400 km LEO
        const v = Math.sqrt(PHYSICS.GM / r);
        state.pos = { x: -r, y: 0 };
        state.vel = { x: 0, y: -v };    // åˆ‡å‘åœ†è½¨é“
        state.path = [];
        state.particles = [];
        view.zoom = 1.0;
        view.x = 0;
        view.y = 0;
    }

    function init() {
        resize();
        buildRefOrbits();
        resetSim();
        running = true;
        loop();
    }

    // è®¡ç®—å½“å‰è½¨é“è¦ç´ 
    function computeOrbit(pos, vel) {
        const mu = PHYSICS.GM;
        const r = Math.hypot(pos.x, pos.y);
        const v = Math.hypot(vel.x, vel.y);
        const E = (v*v)/2 - mu/r;
        const h = pos.x*vel.y - pos.y*vel.x;
        const eTerm = 1 + (2 * E * h*h) / (mu*mu);
        const e = eTerm > 0 ? Math.sqrt(eTerm) : 0;
        const a = -mu / (2 * E);
        let ra = a * (1 + e) - PHYSICS.R;
        let rp = a * (1 - e) - PHYSICS.R;
        if (E >= 0) {          // éé—­åˆè½¨é“
            ra = 999999;
            rp = h*h/mu - PHYSICS.R;
        }
        return { r, v, E, h, e, a, ra, rp };
    }

    // è‡ªåŠ¨è„‰å†²å˜è½¨ï¼šå­¦ç”Ÿåªæ§åˆ¶æ—¶æœº
    function performBurn(sign) {
        const pos = state.pos;
        const vel = state.vel;
        const orb = computeOrbit(pos, vel);
        const r = orb.r;
        const vMag = orb.v;
        if (vMag === 0) return;

        let newVmag = vMag;
        const mu = PHYSICS.GM;
        const tol = 2000; // GEO å®¹å·® 2000 km

        if (sign > 0) {
            // åŠ é€Ÿï¼šä¼˜å…ˆæŒ‰éœæ›¼é€»è¾‘
            if (orb.ra < GEO_ALT - tol) {
                // ç¬¬ä¸€æ¬¡çƒ§ï¼šåœ¨è¿‘åœ°ç‚¹ï¼ŒæŠŠè¿œåœ°ç‚¹æŠ¬åˆ° GEO
                const rp_now = r;
                const ra_target = GEO_R;
                const a = (rp_now + ra_target) / 2;
                newVmag = Math.sqrt(mu * (2/r - 1/a));
            } else if (Math.abs(orb.ra - GEO_ALT) < tol && orb.rp < GEO_ALT - tol) {
                // ç¬¬äºŒæ¬¡çƒ§ï¼šåœ¨è¿œåœ°ç‚¹ï¼ŒæŠŠè½¨é“åœ†åŒ–åˆ° GEO
                const rTarget = GEO_R;
                newVmag = Math.sqrt(mu / rTarget);
            } else {
                // å…¶å®ƒæƒ…å†µï¼šå°å¹… 5% åŠ é€Ÿ
                newVmag = vMag * 1.05;
            }
        } else {
            // å‡é€Ÿï¼šç»Ÿä¸€å°å¹… 5% å‡é€Ÿ
            newVmag = vMag * 0.95;
        }

        // æ²¿å½“å‰é€Ÿåº¦æ–¹å‘è°ƒæ•´åˆ° newVmag
        const ux = vel.x / vMag;
        const uy = vel.y / vMag;
        state.vel.x = ux * newVmag;
        state.vel.y = uy * newVmag;

        // æŒ‰é’®åé¦ˆ
        const btn = sign > 0 ? ui.btnAccel : ui.btnDecel;
        btn.classList.add('active');
        setTimeout(() => btn.classList.remove('active'), 120);

        // æ›´æ˜æ˜¾ã€çœŸå®çš„å°¾ç„°
        const sprayDir = -Math.sign(sign) || -1;
        for (let i = 0; i < 150; i++) {
            const scatter = (Math.random() - 0.5) * 6;   // æ‰©æ•£
            const speedBoost = 4 + Math.random() * 3;    // é«˜é€Ÿå–·å°„
            state.particles.push({
                x: state.pos.x,
                y: state.pos.y,
                vx: vel.x + ux * sprayDir * speedBoost + scatter,
                vy: vel.y + uy * sprayDir * speedBoost + scatter,
                life: 1.6,                               // å°¾ç„°å¯¿å‘½
                type: sign,
                size: 250 + Math.random() * 200          // å°¾ç„°åŸºç¡€å°ºå¯¸
            });
        }
    }

    ui.btnAccel.addEventListener('click', () => performBurn(1));
    ui.btnDecel.addEventListener('click', () => performBurn(-1));

    window.setTime = (val) => {
        state.timeScale = val;
        ui.timeOpts.forEach(b => b.classList.remove('active'));
        Array.from(ui.timeOpts).find(b => b.innerText.includes(val)).classList.add('active');
    };

    function getAcc(p) {
        const r2 = p.x*p.x + p.y*p.y;
        const r = Math.sqrt(r2);
        const ag = -PHYSICS.GM / (r2 * r);
        return { x: ag * p.x, y: ag * p.y };
    }

    function update() {
        const dt = 1.0; 
        let steps = state.timeScale >= 100 ? 20 : state.timeScale;
        let simDt = (dt * state.timeScale) / 60 / steps;

        for(let i=0; i<steps; i++) {
            let p = state.pos;
            let v = state.vel;

            let k1v = getAcc(p);
            let k1p = v;

            let k2p = { x: v.x + k1v.x * 0.5 * simDt, y: v.y + k1v.y * 0.5 * simDt };
            let k2v = getAcc({ x: p.x + k1p.x * 0.5 * simDt, y: p.y + k1p.y * 0.5 * simDt });

            let k3p = { x: v.x + k2v.x * 0.5 * simDt, y: v.y + k2v.y * 0.5 * simDt };
            let k3v = getAcc({ x: p.x + k2p.x * 0.5 * simDt, y: p.y + k2p.y * 0.5 * simDt });

            let k4p = { x: v.x + k3v.x * simDt, y: v.y + k3v.y * simDt };
            let k4v = getAcc({ x: p.x + k3p.x * simDt, y: p.y + k3p.y * simDt });

            state.pos.x += (simDt/6) * (k1p.x + 2*k2p.x + 2*k3p.x + k4p.x);
            state.pos.y += (simDt/6) * (k1p.y + 2*k2p.y + 2*k3p.y + k4p.y);
            state.vel.x += (simDt/6) * (k1v.x + 2*k2v.x + 2*k3v.x + k4v.x);
            state.vel.y += (simDt/6) * (k1v.y + 2*k2v.y + 2*k3v.y + k4v.y);

            if (state.pos.x**2 + state.pos.y**2 < PHYSICS.R**2) resetSim();
        }

        if (Math.random() > 0.5) { 
            state.path.push({...state.pos});
            if(state.path.length > 2000) state.path.shift();
        }

        for (let i = state.particles.length - 1; i >= 0; i--) {
            let p = state.particles[i];
            p.life -= 0.05;
            p.x += p.vx * 0.2;
            p.y += p.vy * 0.2;
            if (p.life <= 0) state.particles.splice(i, 1);
        }
        
        updateTelemetry();
    }

    function updateTelemetry() {
        const orb = computeOrbit(state.pos, state.vel);
        const r = orb.r;
        const v = orb.v;
        const ra = orb.ra;
        const rp = orb.rp;

        ui.alt.innerText = (r - PHYSICS.R).toFixed(0);
        ui.vel.innerText = v.toFixed(2);   // km/s
        ui.apo.innerText = ra > 900000 ? "âˆ" : ra.toFixed(0);
        ui.peri.innerText = rp.toFixed(0);

        const maxV = 11.0;
        const maxR = PHYSICS.R + 40000;
        const kePct = Math.min(100, (v / maxV) * 100);
        const pePct = Math.min(100, (r / maxR) * 100);
        ui.barKe.style.width = kePct + "%";
        ui.barPe.style.width = pePct + "%";
    }

    // ç”»å‚è€ƒè½¨é“è™šçº¿
    function drawRefOrbits(s) {
        ctx.save();
        const dash = [10 / s, 10 / s];
        ctx.setLineDash(dash);
        ctx.lineWidth = 2 / s;

        function drawOrbit(points, color) {
            if (!points.length) return;
            ctx.beginPath();
            points.forEach((p, i) => {
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.strokeStyle = color;
            ctx.stroke();
        }

        drawOrbit(refOrbits.leo, 'rgba(76,201,240,0.6)');   // LEO
        drawOrbit(refOrbits.transfer, 'rgba(255,80,200,0.7)'); // è½¬ç§»è½¨é“
        drawOrbit(refOrbits.geo, 'rgba(255,220,0,0.6)');    // GEO

        ctx.setLineDash([]);
        ctx.restore();
    }

    // ç”»å«æ˜Ÿé€Ÿåº¦ç®­å¤´ï¼šæ–¹å‘ + é•¿åº¦ âˆ é€Ÿåº¦å¤§å°ï¼ˆç»†é•¿ã€å¼ºåŒ–ç‰ˆï¼‰
    function drawVelocityArrow(s) {
        const vx = state.vel.x;
        const vy = state.vel.y;
        const vMag = Math.hypot(vx, vy);
        if (vMag <= 0) return;

        // æ”¾å¤§ç®­å¤´é•¿åº¦ï¼Œä½†ä¿æŒçº¿æ¡çº¤ç»†
        const lenScale = 1000;                          // å†³å®šç®­å¤´æ‹‰ä¼¸å€ç‡
        const minLen   = 1000;                          // æœ€çŸ­é•¿åº¦
        const maxLen   = PHYSICS.R * 8.0;              // æœ€å¤§é•¿åº¦ï¼ˆçº¦ 6 ä¸ªåœ°çƒåŠå¾„ï¼‰

        const arrowLen = Math.max(minLen, Math.min(maxLen, vMag * lenScale));

        const sx = state.pos.x;
        const sy = state.pos.y;

        const ux = vx / vMag;
        const uy = vy / vMag;

        const ex = sx + ux * arrowLen;
        const ey = sy + uy * arrowLen;

        ctx.save();
        ctx.lineWidth = 1.8 / s;                       // ç»†çº¿
        ctx.strokeStyle = 'rgba(0, 255, 140, 0.95)';     // äº®ç»¿è‰²
        ctx.fillStyle   = 'rgba(0, 255, 140, 0.95)';

        // ä¸»ç®­æ†
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(ex, ey);
        ctx.stroke();

        // ç®­å¤´ä¸‰è§’
        const headLen   = Math.min(arrowLen * 0.20, 450);
        const headWidth = headLen * 0.45;

        const hx = ex, hy = ey;
        const bx = hx - ux * headLen;
        const by = hy - uy * headLen;

        const leftX  = bx + (-uy)*headWidth;
        const leftY  = by + ( ux)*headWidth;
        const rightX = bx - (-uy)*headWidth;
        const rightY = by - ( ux)*headWidth;

        ctx.beginPath();
        ctx.moveTo(hx, hy);
        ctx.lineTo(leftX, leftY);
        ctx.lineTo(rightX, rightY);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }

    function draw() {
        const w = window.innerWidth;
        const h = window.innerHeight;

        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, h);

        const cx = w / 2 + view.x;
        const cy = h / 2 + view.y;
        const s = PHYSICS.scale * view.zoom;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(s, s);

        // å‚è€ƒè½¨é“
        drawRefOrbits(s);

        // åœ°çƒ
        const r = PHYSICS.R;
        if (earthImg.complete && earthImg.naturalWidth !== 0) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI*2);
            ctx.clip();
            ctx.drawImage(earthImg, -r*1.01, -r*1.01, r*2.02, r*2.02);
            ctx.restore();
        } else {
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI*2);
            ctx.fillStyle = '#1e3a8a';
            ctx.fill();
            ctx.strokeStyle='#fff';
            ctx.lineWidth=50;
            ctx.stroke();
        }

        // å®é™…è½¨è¿¹
        if (state.path.length > 1) {
            ctx.beginPath();
            state.path.forEach((p, i) => {
                if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
            });
            ctx.strokeStyle = '#4cc9f0';
            ctx.lineWidth = 2 / s;
            ctx.stroke();
        }

        // å°¾ç„°ç²’å­
        state.particles.forEach(p => {
            const heat = Math.max(0, p.life);
            ctx.fillStyle = p.type === 1
                ? `rgba(255, ${120 + heat*100}, 0, ${heat})`
                : `rgba(0, 160, 255, ${heat})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * heat, 0, Math.PI * 2);
            ctx.fill();
        });

        // å«æ˜Ÿä¸»ä½“
        ctx.fillStyle = '#fff';
        const satR = Math.max(100, 5/s);
        ctx.beginPath();
        ctx.arc(state.pos.x, state.pos.y, satR, 0, Math.PI*2);
        ctx.fill();

        // é€Ÿåº¦ç®­å¤´
        drawVelocityArrow(s);

        ctx.restore();
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    canvas.addEventListener('mousedown', e => {
        view.dragging = true;
        view.lastX = e.clientX;
        view.lastY = e.clientY;
    });
    window.addEventListener('mousemove', e => {
        if(view.dragging) {
            view.x += e.clientX - view.lastX;
            view.y += e.clientY - view.lastY;
            view.lastX = e.clientX;
            view.lastY = e.clientY;
        }
    });
    window.addEventListener('mouseup', () => view.dragging = false);

    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        view.zoom *= (1 - e.deltaY * 0.001);
        view.zoom = Math.max(0.05, Math.min(view.zoom, 5.0));
    }, {passive:false});

    init();
</script>
</body>
</html>
